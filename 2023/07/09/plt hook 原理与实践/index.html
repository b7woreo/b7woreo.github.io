<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.chrnie.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言在 Android 应用开中, 针对于 native 的 hook 方案主要分为两种:  PLT Hook: 基于地址无关代码(PIC, Position-independent Code)原理设计的 hook 方案, 可用于 hook 对外部函数的调用, 代表项目: bhook. Inline Hook: 通过在代码段中插入新的指令实现 hook 的方案, 代表项目: android-inl">
<meta property="og:type" content="article">
<meta property="og:title" content="plt hook 原理与实践">
<meta property="og:url" content="https://blog.chrnie.com/2023/07/09/plt%20hook%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/index.html">
<meta property="og:site_name" content="Know it &amp; why">
<meta property="og:description" content="前言在 Android 应用开中, 针对于 native 的 hook 方案主要分为两种:  PLT Hook: 基于地址无关代码(PIC, Position-independent Code)原理设计的 hook 方案, 可用于 hook 对外部函数的调用, 代表项目: bhook. Inline Hook: 通过在代码段中插入新的指令实现 hook 的方案, 代表项目: android-inl">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186761cff90448da90a30e5261622444~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://blog.chrnie.com/images/20230709234507.png">
<meta property="og:image" content="https://blog.chrnie.com/images/20230709234522.png">
<meta property="article:published_time" content="2023-07-09T00:00:00.000Z">
<meta property="article:modified_time" content="2023-07-09T15:48:28.492Z">
<meta property="article:author" content="陈仁杰">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186761cff90448da90a30e5261622444~tplv-k3u1fbpfcp-watermark.image">

<link rel="canonical" href="https://blog.chrnie.com/2023/07/09/plt%20hook%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>plt hook 原理与实践 | Know it & why</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b18fd7c4e0d67aa2c74c2020a3b56d7a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Know it & why</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">知其然也知其所以然</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.chrnie.com/2023/07/09/plt%20hook%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="陈仁杰">
      <meta itemprop="description" content="Android Developer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Know it & why">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          plt hook 原理与实践
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-07-09 00:00:00 / 修改时间：15:48:28" itemprop="dateCreated datePublished" datetime="2023-07-09T00:00:00Z">2023-07-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 Android 应用开中, 针对于 native 的 hook 方案主要分为两种:</p>
<ul>
<li><strong>PLT Hook:</strong> 基于地址无关代码(PIC, Position-independent Code)原理设计的 hook 方案, 可用于 hook 对外部函数的调用, 代表项目: <a target="_blank" rel="noopener" href="https://github.com/bytedance/bhook">bhook</a>.</li>
<li><strong>Inline Hook:</strong> 通过在代码段中插入新的指令实现 hook 的方案, 代表项目: <a target="_blank" rel="noopener" href="https://github.com/bytedance/android-inline-hook">android-inline-hook</a>.</li>
</ul>
<p>本文主要对 PLT Hook 的原理进行探索和实践.</p>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><h2 id="ELF-文件"><a href="#ELF-文件" class="headerlink" title="ELF 文件"></a>ELF 文件</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186761cff90448da90a30e5261622444~tplv-k3u1fbpfcp-watermark.image"></p>
<p>ELF 全称: Executable and Linkable Format, 是 Unix 和类 Unix 系统的标准二进制文件格式. 常见的 ELF 文件有:</p>
<ul>
<li><strong>可重定位文件(Relocatable File):</strong> 这类文件包含了代码和数据, 可以被用来链接成可执行文件或共享目标文件.</li>
<li><strong>可执行文件(Executable File):</strong> 这类文件包含了可以直接执行的程序, 它们一般都没有扩展名.</li>
<li><strong>共享目标文件(Shared Object File):</strong> 这种文件包含了代码和数据, 可以在以下两种情况下使用: 一种时链接器可以使用这种文件跟其他的可重定位文件和共享目标文件链接, 产生新的目标文件; 第二种是动态链接器可以将几个这种共享目标文件与可执行文件结合, 做为进程映像的一部分来运行.</li>
</ul>
<p>ELF 文件主要是由各类 <strong>段</strong> 组成, 在不同的视图模型下 <strong>段</strong> 会有不同的含义.</p>
<h3 id="链接视图"><a href="#链接视图" class="headerlink" title="链接视图"></a>链接视图</h3><p>在 ELF 文件被加载到内存之前, 编译器主要是通过读取 <code>Section header table</code> 中的信息, 以 <code>Section</code> 为单元操作修改 ELF 文件.<br>下面是进行 PLT Hook 所需要涉及的 <code>Section</code> 类型, 具体用法在后续章节讲解.</p>
<ul>
<li><code>.dynamic</code>: 保存了动态链接器所需要的基本信息, 比如动态链接的符号表的位置, 动态链接重定位表的位置等.</li>
<li><code>.dynsym</code>: 与动态链接相关的符号, 不包括模块内部的符号.</li>
<li><code>.dynstr</code>: 动态链接时的符号字符串表.</li>
<li><code>.rel.dyn / .rela.dyn</code>: 用于数据重定位, 重定位的位置位于 <code>.got</code>.</li>
<li><code>.rel.plt / .rela.plt</code>: 用于函数重定位, 重定位的位置位于 <code>.got.plt</code>.</li>
<li><code>.got</code>: 外部数据跳转表.</li>
<li><code>.got.plt</code>: 外部函数跳转表.</li>
<li><code>.plt</code>: 外部函数调用中间表, 用于实现函数延迟绑定.</li>
</ul>
<h3 id="执行视图"><a href="#执行视图" class="headerlink" title="执行视图"></a>执行视图</h3><p>当 ELF 文件被加载时(无论是可执行文件还是动态链接库), 系统内核会读取 <code>Program header table</code> 中的信息, 以 <code>Fragment</code> 为单元使用页映射的方式将 ELF 文件加载到内存中.<br>执行视图相较于链接视图, 会将多个拥有相同内存权限的 <code>Section</code> 合并到一个的 <code>Fragment</code> 中.</p>
<h2 id="动态库加载"><a href="#动态库加载" class="headerlink" title="动态库加载"></a>动态库加载</h2><p>PLT Hook 主要涉及的是共享目标文件, 下面将介绍动态链接库加载时会使用到的两个关键技术.</p>
<h3 id="地址无关代码-PIC"><a href="#地址无关代码-PIC" class="headerlink" title="地址无关代码(PIC)"></a>地址无关代码(PIC)</h3><p>动态链接相较于静态链接最大的区别在于符号的地址信息在被加载时才知道, 于是编译器会把符号的处理分成两类:</p>
<ul>
<li>模块内部符号: 在编译期可以知道相对地址, 在运行期使用相对地址进行访问.</li>
<li>模块外部符号: 编译期在 <code>.got</code> 中预留地址空间, 在动态链接库被加载时由动态链接器负责填入正确的地址.</li>
</ul>
<p>于是动态链接库中 <code>.data</code> 和 <code>.text</code> 的内存数据可以在多个进程中共享, 每个进程又会有自己的独享的 <code>.got</code> 内存数据. 当动态链接库调用外部函数时流程:</p>
<p><img src="/images/20230709234507.png"></p>
<h3 id="延迟绑定-PLT"><a href="#延迟绑定-PLT" class="headerlink" title="延迟绑定(PLT)"></a>延迟绑定(PLT)</h3><p>PIC 有一个缺点, 就是在动态链接库被加载时需要完成对所有符号的处理工作, 这会影响程序的启动速度. 于是在 PIC 的基础上衍生出了 PLT 技术. 当动态链接库调用外部函数时流程:</p>
<p><img src="/images/20230709234522.png"></p>
<p>相较于 PIC, PLT 多出了 <code>.plt</code> 这个中间跳转表, <code>.plt</code> 中的大致逻辑:</p>
<ol>
<li>判断函数符号在 <code>.got.plt</code> 中的地址是否已经初始化, 如已初始化跳转至步骤 <code>3</code>, 否则执行步骤 <code>2</code>;</li>
<li>使用 <code>_dl_runtime_resolve</code> 初始化 <code>.got.plt</code> 中的函数符号地址;</li>
<li>读取 <code>.got.plt</code> 中的对应函数符号地址, 跳转至该地址完成函数执行.</li>
</ol>
<h2 id="原理总结"><a href="#原理总结" class="headerlink" title="原理总结"></a>原理总结</h2><p>动态链接库使用到外部符号时, 一定会通过 <code>.got</code> 或 <code>.got.plt</code> 确定符号运行时的地址, 所以只要在运行时修改 <code>.got</code> 和 <code>.got.plt</code> 中的符号地址信息, 就能实现 hook 操作.</p>
<h1 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h1><p>在知晓 PLT Hook 的基本原理后, 下面将在 Linux 操作系统中动手进行实践: </p>
<ol>
<li>编写一个动态库, 动态库中会使用到 <code>printf</code> 函数;</li>
<li>通过 <code>dl_iterate_phdr</code> 在程序运行时获取动态库的信息, 并完成对 <code>printf</code> 的 hook 操作.</li>
</ol>
<h2 id="编写动态库"><a href="#编写动态库" class="headerlink" title="编写动态库"></a>编写动态库</h2><p>文件: lib.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hello_world</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>文件: lib.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello_world</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过执行 <code>gcc -fPIC --shared lib.c -o lib.so</code> 命令得到可用于动态链接的 <code>lib.so</code> 文件.</p>
<h2 id="编写主程序"><a href="#编写主程序" class="headerlink" title="编写主程序"></a>编写主程序</h2><p>文件: main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;link.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;before printf: %s\n&quot;</span>, str);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;after printf: %s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  hook();</span><br><span class="line">  hello_world();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hook</span><span class="params">()</span> &#123; </span><br><span class="line">  <span class="comment">// 见: &quot;编写 hook 操作&quot; 章节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过执行 <code>gcc main.c lib.so -Wl,-rpath ./ -o main</code> 命令得到可用于执行的 <code>main</code> 文件, <code>main</code> 在运行时会动态链接 <code>lib.so</code> 文件.<br><code>-Wl,-rpath ./</code> 指定了运行时共享目标文件查找目录, 所以运行时要保证 <code>main</code> 和 <code>lib.so</code> 文件在同一个目录下.</p>
<h2 id="确认基本信息"><a href="#确认基本信息" class="headerlink" title="确认基本信息"></a>确认基本信息</h2><h3 id="符号名"><a href="#符号名" class="headerlink" title="符号名"></a>符号名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d lib.so</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">0000000000001050 &lt;puts@plt&gt;:</span><br><span class="line">    1050:       f3 0f 1e fa             endbr64 </span><br><span class="line">    1054:       f2 ff 25 bd 2f 00 00    bnd jmpq *0x2fbd(%rip)        <span class="comment"># 4018 &lt;puts@GLIBC_2.2.5&gt;</span></span><br><span class="line">    105b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">0000000000001119 &lt;hello_world&gt;:</span><br><span class="line">    1119:       f3 0f 1e fa             endbr64 </span><br><span class="line">    111d:       55                      push   %rbp</span><br><span class="line">    111e:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">    1121:       48 8d 3d d8 0e 00 00    lea    0xed8(%rip),%rdi        <span class="comment"># 2000 &lt;_fini+0xed0&gt;</span></span><br><span class="line">    1128:       e8 23 ff ff ff          callq  1050 &lt;puts@plt&gt;</span><br><span class="line">    112d:       90                      nop</span><br><span class="line">    112e:       5d                      pop    %rbp</span><br><span class="line">    112f:       c3                      retq   </span><br></pre></td></tr></table></figure>

<p>通过 <code>objdump</code> 命令可以看到, <code>hello_world</code> 中的 <code>printf</code> 函数调用被替换成了 <code>puts@plt</code> 函数, 而 <code>puts@plt</code> 函数最终会调用 <code>puts@GLIBC_2.2.5</code> 函数. 因此接下来将需要修改 <code>.got.plt</code> 中 <code>puts</code> 函数的地址. </p>
<h3 id="重定位表结构"><a href="#重定位表结构" class="headerlink" title="重定位表结构"></a>重定位表结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d lib.so</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x2e20 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 ELF 文件中, 有两种格式的重定位表: <code>rel</code> 和 <code>rela</code>, 为了简化下面的 hook 逻辑这里先通过 <code>readelf</code> 读取 <code>.dynamic</code> 段中 <code>PLTREL</code> 的信息得知 <code>lib.so</code> 中使用的是 <code>rela</code> 格式, 因此在下面进行 hook 操作时将进行一些简化, 不再对重定位表的格式进行判断.</p>
<h3 id="内存权限"><a href="#内存权限" class="headerlink" title="内存权限"></a>内存权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -l lib.so</span><br><span class="line"></span><br><span class="line">Elf file <span class="built_in">type</span> is DYN (Shared object file)</span><br><span class="line">Entry point 0x1060</span><br><span class="line">There are 11 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000530 0x0000000000000530  R      0x1000</span><br><span class="line">  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000</span><br><span class="line">                 0x000000000000013d 0x000000000000013d  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000</span><br><span class="line">                 0x00000000000000cc 0x00000000000000cc  R      0x1000</span><br><span class="line">  LOAD           0x0000000000002e10 0x0000000000003e10 0x0000000000003e10</span><br><span class="line">                 0x0000000000000218 0x0000000000000220  RW     0x1000</span><br><span class="line">  DYNAMIC        0x0000000000002e20 0x0000000000003e20 0x0000000000003e20</span><br><span class="line">                 0x00000000000001c0 0x00000000000001c0  RW     0x8</span><br><span class="line">  NOTE           0x00000000000002a8 0x00000000000002a8 0x00000000000002a8</span><br><span class="line">                 0x0000000000000020 0x0000000000000020  R      0x8</span><br><span class="line">  NOTE           0x00000000000002c8 0x00000000000002c8 0x00000000000002c8</span><br><span class="line">                 0x0000000000000024 0x0000000000000024  R      0x4</span><br><span class="line">  GNU_PROPERTY   0x00000000000002a8 0x00000000000002a8 0x00000000000002a8</span><br><span class="line">                 0x0000000000000020 0x0000000000000020  R      0x8</span><br><span class="line">  GNU_EH_FRAME   0x000000000000200c 0x000000000000200c 0x000000000000200c</span><br><span class="line">                 0x000000000000002c 0x000000000000002c  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x0000000000002e10 0x0000000000003e10 0x0000000000003e10</span><br><span class="line">                 0x00000000000001f0 0x00000000000001f0  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .note.gnu.property .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt </span><br><span class="line">   01     .init .plt .plt.got .plt.sec .text .fini </span><br><span class="line">   02     .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   03     .init_array .fini_array .dynamic .got .got.plt .data .bss </span><br><span class="line">   04     .dynamic </span><br><span class="line">   05     .note.gnu.property </span><br><span class="line">   06     .note.gnu.build-id </span><br><span class="line">   07     .note.gnu.property </span><br><span class="line">   08     .eh_frame_hdr </span><br><span class="line">   09     </span><br><span class="line">   10     .init_array .fini_array .dynamic .got </span><br></pre></td></tr></table></figure>

<p>在 <code>Section to Segment mapping</code> 中可以找到 hook 时需要修改的 <code>.got.plt</code> 位于 <code>03</code> 段中, 而在 <code>Program Headers</code> 中找到 <code>03</code> 段的信息可以看到 <code>Flags</code> 是 <code>RW</code>, 因此可以在运行时直接对 <code>.got.plt</code> 中的信息进行修改.</p>
<h2 id="编写-hook-操作"><a href="#编写-hook-操作" class="headerlink" title="编写 hook 操作"></a>编写 hook 操作</h2><p>基于 PLT Hook 的基本原理, <code>hook</code> 函数的实现主要分为以下几个步骤:</p>
<ol>
<li>通过 <code>dl_iterate_phdr</code> 遍历当前进程中所有 <code>.so</code> 的信息, 找到 <code>lib.so</code> 的地址;</li>
<li>遍历 <code>.dynamic</code> 段中的信息, 找到 <code>.rela.plt</code> 的地址;</li>
<li>遍历 <code>.rela.plt</code>段中的信息, 找到 <code>.got.plt</code> 段中 <code>puts</code> 函数的地址;</li>
<li>将 <code>.got.plt</code> 段中 <code>puts</code> 函数的地址改为 <code>my_printf</code> 函数的地址.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">callback</span><span class="params">(<span class="keyword">struct</span> dl_phdr_info *info, <span class="type">size_t</span> size, <span class="type">void</span> *data)</span> &#123;</span><br><span class="line">  <span class="comment">// 判断当前动态库是否是 `./lib.so` 的动态库的信息, 不如不是则跳过</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;./lib.so&quot;</span>, info-&gt;dlpi_name) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 待从 .dynamic 段中查找出的信息</span></span><br><span class="line">  <span class="type">int</span> pltrelsz = <span class="number">0</span>; <span class="comment">// .rela.plt 段大小</span></span><br><span class="line">  <span class="type">char</span> *dynstr = <span class="literal">NULL</span>; <span class="comment">// .dynstr 段起始地址</span></span><br><span class="line">  ElfW(Rela) *rela_plt = <span class="literal">NULL</span>; <span class="comment">// .rela.plt 段起始地址</span></span><br><span class="line">  ElfW(Sym) *dynsym = <span class="literal">NULL</span>; <span class="comment">// .dynsym 段起始地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历当前动态库中所有段的信息</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; info-&gt;dlpi_phnum; i++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *phdr = &amp;info-&gt;dlpi_phdr[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是 .dynamic 段则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type != PT_DYNAMIC) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dynEntryCount = phdr-&gt;p_memsz / <span class="keyword">sizeof</span>(ElfW(Dyn));</span><br><span class="line">    ElfW(Dyn) *dyn = (ElfW(Dyn) *)(phdr-&gt;p_offset + info-&gt;dlpi_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历获取 .dynamic 段中的信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dynEntryCount; j++) &#123;</span><br><span class="line">      ElfW(Dyn) *entry = &amp;dyn[j];</span><br><span class="line">      <span class="keyword">switch</span> (dyn-&gt;d_tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> DT_PLTRELSZ: &#123;</span><br><span class="line">        pltrelsz = dyn-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DT_JMPREL: &#123;</span><br><span class="line">        rela_plt = (ElfW(Rela) *)(info-&gt;dlpi_addr + dyn-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DT_STRTAB: &#123;</span><br><span class="line">        dynstr = (<span class="type">char</span> *)(info-&gt;dlpi_addr + dyn-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DT_SYMTAB: &#123;</span><br><span class="line">        dynsym = (ElfW(Sym) *)(info-&gt;dlpi_addr + dyn-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      dyn++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 .rela.plt 段中的信息</span></span><br><span class="line">  <span class="type">int</span> relaEntryCount = pltrelsz / <span class="keyword">sizeof</span>(ElfW(Rela));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; relaEntryCount; i++) &#123;</span><br><span class="line">    ElfW(Rela) *entry = &amp;rela_plt[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 .dynsym 中的索引</span></span><br><span class="line">    <span class="type">int</span> r_sym = ELF64_R_SYM(entry-&gt;r_info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 .dynstr 中的索引</span></span><br><span class="line">    <span class="type">int</span> st_name = dynsym[r_sym].st_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的符号名称</span></span><br><span class="line">    <span class="type">char</span> *name = &amp;dynstr[st_name];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是 `puts` 符号, 则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;puts&quot;</span>, name) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 `puts` 符号在 .got.plt 表中的位置</span></span><br><span class="line">    <span class="type">uintptr_t</span> hook_point = (<span class="type">uintptr_t</span>)(info-&gt;dlpi_addr + entry-&gt;r_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 `puts` 符号的跳转地址为: my_printf</span></span><br><span class="line">    *(<span class="type">void</span> **)hook_point = my_printf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hook</span><span class="params">()</span> &#123; dl_iterate_phdr(callback, <span class="literal">NULL</span>); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">before <span class="built_in">printf</span>: hello world</span><br><span class="line">hello world</span><br><span class="line">after <span class="built_in">printf</span>: hello world</span><br></pre></td></tr></table></figure>

<p>通过 <code>./main</code> 命令运行主程序, 将会得到下面的输出, 可以看到在 <code>hello world</code> 前后多了两行输出, 说明 lib.so 中的 <code>printf</code> 函数调用已经被替换成了 <code>my_printf</code>.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>&lt;程序员的自我修养 – 链接, 装载与库&gt;</li>
<li><a target="_blank" rel="noopener" href="https://github.com/caikelun/caikelun.github.io/blob/master/site/blog/2018-05-01-android-plt-hook-overview.md">Android PLT hook 概述</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/caikelun/caikelun.github.io/blob/master/site/blog/2021-08-19-bytedance-open-source-bytehook.md">字节跳动开源 Android PLT hook 方案 ByteHook</a></li>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/dl_iterate_phdr.3.html">dl_iterate_phdr</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-42444.html">Dynamic Section</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-79797.html#scrolltoc">Symbol Table Section
</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-54839.html#scrolltoc">Relocation Sections</a></li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>陈仁杰
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.chrnie.com/2023/07/09/plt%20hook%20%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="plt hook 原理与实践">https://blog.chrnie.com/2023/07/09/plt hook 原理与实践/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/06/03/AGP8.0%20%E6%97%B6%E4%BB%A3%E7%9A%84%20Transform%20%E5%AE%9E%E8%B7%B5/" rel="prev" title="AGP8.0 时代的 Transform 实践">
      <i class="fa fa-chevron-left"></i> AGP8.0 时代的 Transform 实践
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ELF-%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">ELF 文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E8%A7%86%E5%9B%BE"><span class="nav-number">2.1.1.</span> <span class="nav-text">链接视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%A7%86%E5%9B%BE"><span class="nav-number">2.1.2.</span> <span class="nav-text">执行视图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.2.</span> <span class="nav-text">动态库加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81-PIC"><span class="nav-number">2.2.1.</span> <span class="nav-text">地址无关代码(PIC)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A-PLT"><span class="nav-number">2.2.2.</span> <span class="nav-text">延迟绑定(PLT)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93"><span class="nav-number">2.3.</span> <span class="nav-text">原理总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.</span> <span class="nav-text">代码实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">3.1.</span> <span class="nav-text">编写动态库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.2.</span> <span class="nav-text">编写主程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AE%E8%AE%A4%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="nav-number">3.3.</span> <span class="nav-text">确认基本信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%90%8D"><span class="nav-number">3.3.1.</span> <span class="nav-text">符号名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.2.</span> <span class="nav-text">重定位表结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%9D%83%E9%99%90"><span class="nav-number">3.3.3.</span> <span class="nav-text">内存权限</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99-hook-%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.</span> <span class="nav-text">编写 hook 操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C"><span class="nav-number">3.5.</span> <span class="nav-text">最终效果</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">4.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="陈仁杰"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">陈仁杰</p>
  <div class="site-description" itemprop="description">Android Developer</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈仁杰</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'b9b101e57cbe4d28880b',
      clientSecret: 'e22ee5c754093833a25dfb504570589d9ea44e70',
      repo        : 'blog-comment',
      owner       : 'renjie-c',
      admin       : ['renjie-c'],
      id          : '48335b257ebeed9cdae6372b27f8b41f',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
